# 기본 인증
수많은 사람들이 웹을 통해 개인적인 업무를 보거나 개인적인 데이터에 접근한다.
이때 데이터에는 허가된 사람만이 접근할 수 있어야 한다.
그러기 위해서는 서버가 사용자가 누구인지 식별할 수 있어야 한다.
## 12.1 인증
인증은 당신이 누구인지 증명하는 것이다.
완벽한 인증이란 없지만 여러 데이터는 당신이 누구인지 판단하는데 도움이 된다.

### 12.1.1 HTTP의 인증요구/응답 프레임워크
HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

웹 애플리케이션이 HTTP 요청 메시지를 받으면 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증요구'로 응답할 수 있다.
사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야 한다.

### 12.1.2 인증 프로토콜과 헤더
HTTP는 필요에 따라 고쳐 끌 수 있는 제어 헤더를 통해 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.
HTTP에는 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.

서버가 사용자에게 인증 요구를 보낼 때 서버는 401 응답과 함께 WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할 지 설명한다.
다음으로 클라이언트가 서버로 인증하려면 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authirization 헤더에 담아서 요청을 다시 보낸다.
인증 요청이 성공적으로 완료되면 서버는 정상적인 상태 코드를 반환하며 추가적인 Authentication-Info 헤더에 기술할 수 있다.

### 12.1.3 보안 영역
기본 인증을 자세히 살펴보기에 앞서, HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 설명할 필요가 있다. 서버가 클라이언트로 인증 요구를 할 때, realm 지시자가 기술되어 있는 WWW-Authenicate 헤더를 봤을 것이다. 웹 서버는 기밀문서를 보안 영역 그룹으로 나누고 보안 영역은 저마다 다른 사용자 권한을 요구한다.

## 12.2 기본 인증
기본 인증은 가장 잘 알려진 HTTP 인증 규약이다. 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있다. 기본 인증은 원래 HTTP/1.0에 기술되어 있었지만 HTTP 인증의 상세 내용을 다루는 RFC 2617로 옮겨졌다.
기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다.
서버는 200대신 301 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW_Authenticate에 기술해서 응답하여 인증 요구를 시작한다.
브라우저는 사용자에게 계정과 비밀번호를 입력할 수 있는 대화상자를 열고
브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다.

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩
HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩 한다.

### 12.2.3 프락시 인증
중개 프락시 서버를 통해 인증할 수도 있다.
어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다.
프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋다.

## 12.3 기본 인증의 보안 결함
기본 인증은 단순하고 편리하지만 안심할 수는 없다. 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나 ssl 같은 암호기술과 혼용한다.

기본 인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며 다른 사람들이 보지 않기를 원하지만 보더라도 치명적이지 않은 경우에는 여전히 유용하다.

기본 인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송과 함께 연계해서 사용할 수 있다.
