# 보안 HTTP
이전 장에서 사용자를 식별하고 인증하는 것을 도와주는 HTTP의 기능들을 알아보았다.
이 기법들은 우호적인 관계가 형성되어 있는 커뮤니티에선 잘 동작하지만 
적대행위가 일어날 가능성이 있는 커뮤니티에서 중요한 트랜잭션을 보호하기에는 부족하다.

## 14.1 HTTP를 안전하게 만들기
사람들은 웹 트랜잭션을 중요한 일에 사용한다.
강력한 보안이 없다면 마음놓고 사용할 수 없을 것이다.
웹은 안전한 방식의 HTTP를 필요로 한다.

이전 장에서 인증과 메시지 무결성을 제공하는 가벼운 방법에 대해 이야기 했다.
이들은 대체로 쓸만하지만 충분히 강력하진 않다.

HTTP의 보안 버전은 효율적이고 이식성이 좋아야 하고 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다.

우리는 다음을 지원하는 보안 기술이 필요하다
- 서버인증: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기 하고 있음을 알 수 있어야 한다.
- 클라이언트 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 할 수 있어야 한다.
- 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성: 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성: 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성: 사회의 문제적, 정치적 요구를 만족시켜야 한다.

### 14.1.1 HTTPS
HTTPS는 가장 인기가 많은 HTTP를 안전하게 만드는 방식이다.
HTTPS로 웹페이지에 접근하고 있는 경우 URL이 https://로 시작하는 것을 보고 그 사실을 알아챌 수 있다.

HTTPS를 사용할 경우 모든 요청과 응답 데이터는 암호화된다.
HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, 이 보안 계층은 안전 소켓 계층(SSL) 혹은 그를 계승한 전송 계층 보안(TLS)을 이용하여 구현된다.

어려운 작업은 SSL 라이브러리 안에서 일어나기 때문에
대부분의 경우, TCP 입력/출력 호출을 SSL 호출로 대체하고 보안 정보를 설정하고 관리하기 위한 몇가지 호출을 추가하기만 하면 된다.

### 14.2 디지털 암호학
HTTPS에 대해 자세히 이야기하기 전에 SSL과 HTTPS에서 이용되는 암호인코딩 기법에 대해 배경 지식을 알 필요가 있다.

- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공기키 암호법: 비밀 메시지를 전달하는 수백만대의 컴퓨터를 쉽게 만들 수 있는 시스템 
- 디지털 서명 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학
암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술이다.
암호법은 단순히 다른사람이 메시지를 볼 수 없도록 하는것 뿐만 아니라
변조를 방지하기 위해서도 사용된다.

### 14.2.2 암호(cipher)
암호법은 암호라 불리는 비밀 코드에 기반한다.
암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.
인코딩되기 전의 원본 메시지는 흔히 평문 혹은 텍스트라 부른다.

### 14.2.3 암호 기계
암호는 상대적으로 간단한 알고리즘으로 시작했는데 사람이 직접 인코딩하고 디코딩해야 했기 때문이다.
기술이 진보하며 사람들은 빠르고 정확하게 인코딩, 디코딩 하는 기계를 만들기 시작했다.

### 14.2.4 키가 있는 암호
코드 알고리즘과 기계가 적에 손에 들어갈 수 있기 때문에 대부분의 기계들에는 
암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다.
이런 암호 매개변수를 키라고 부른다.

### 14.2.5 디지털 암호
디지털 계산의 도래로 두가지 주요한 발전이 있다.
- 속도 및 기능
- 큰키의 지원 가능
기계 장치의 물리적 금속 키나 다이얼 설정과는 달리 디지털 키는 그냥 숫자에 불과하다.
디지털 키 값은 인코딩과 디코딩 알고리즘에 대한 입력값이다.
코딩 알고리즘은 이 값에 근거해 인코딩, 디코딩한다.

## 14.3 대칭키 암호법
많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데 그들이 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.

### 14.3.1 키 길이와 열거 공격
비밀 키가 누설되면 안 된다는 것은 매우 중요하다.
좋은 암호 알고리즘은 공격자가 코드를 크래킹하려면 이 우주에 존재하는 모든 가능한 키 값을 시도해보는 것 외에 다른 방법이 없게 만든다.
무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다.
128비트 키라면 2의 128승에 해당하는 값이 가능하다.

### 14.3.2 공유키 발급하기
대칭키 암호의 단점 중 하나는 발송자와 수신자가 대화하려면 둘 다 공유키를 가져야 한다는 것이다.

## 14.4 공개키 암호법
한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.
하나는 호스트의 메시지를 인코딩하기 위한 것이고, 다른 하나는 그 호스트의 메시지를 디코딩 하기 위한 것이다.

인코딩 키는 모두를 위해 공개되어 있고, 디코딩 키는 호스트만이 알고 있다.

공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했가.

### 14.4.1 RSA
공개키 비대칭 암호의 과제는 설혹 악당이 아래 내용을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다.
- 공개키
- 가로채서 얻은 암호문의 일부
- 메시지와 그것을 암호화한 암호문

이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 MIT에서 발명되고 이어서 RSA 데이터 시큐리티에서 상용화된 RSA 알고리즘이다.

### 14.4.2 혼성 암호 체계와 세션 키
비대칭 공개키 암호방식은 안전하게 메시지를 보낼 수 있다는 점은 훌륭하지만
두 노드가 안전하게 의사소통 하려고 할 때 개인 키에 대한 협상을 먼저 해야 할 필요가 있다.

그러나 계산이 느린 경향이 있어 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.

## 14.5 디지털 서명
암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는 데에 이용될 수 있다.

### 14.5.1 서명은 암호 체크섬이다.
디지털 서명은 다음 두가지 이점을 가진다.
- 서명은 메시지를 작성한 저자가 누군지 알려준다.
- 서명은 메시지 위조를 방지한다.
디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인 키는 오직 소유자만이 알고 있기 때문에
저자의 개인 키는 일종의 '지문'처럼 사용된다.

## 14.6 디지털 인증서
디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.
여권과 같이 더욱 신뢰할 만한 형태의 신원 증명은, 서명이 되어 있고 특별한 종이 위에 정부가 새긴 도장이 찍혀있다.

### 14.6.1 인증서의 내부
디지털 인증서에는 또한 공식적으로 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨있다.
- 대상의 이름
- 유효기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명

### 14.6.3 서버 인증을 위해 인증서 사용하기
사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동을 접속한 서버에서 디지털 인증서를 가져온다.
서버인증서는 다음을 포함한 많은 필드를 갖고 있다.
- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명
브라우저가 인증서를 받으면 서명 기관을 검사한다.
만약 그 기관이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며
모르는 곳이라면 브라우저는 신뢰하는지 확인하기 위한 대화상자를 보여준다.
### 14.7 HTTPS의 세부사항
HTTPS는 HTTP의 가장 유명한 보안버전이다.
HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

### 14.7.1 HTTPS 개요
HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.
HTTPS는 HTTP 메시지를 TCP로 보내기 전에 그것들을 암호화하는 보안 계층으로 보낸다.

### 14.7.2 HTTPS 스킴
오늘날 보안 HTTP는 선택적이다. 따라서 웹 서버로의 요청을 만들 때 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.
이것은 URL의 스킴을 통해 이루어진다.

### 14.7.3 보안 전송 셋업
암호화되지 않은 HTTP에서 클라이언트는 웹 서버는 80번 포트로 TCP 커넥션을 열고 요청 메시지를 보내고 응답 메시지를 받고 커넥션을 닫는다.

HTTPS에서의 절차는 SSL 보안 계층 때문에 더 복잡하다.
클라이언트는 먼저 웹 서버의 443 포트로 연결한다. 
일단 연결이 되고 나면, 클라이언트와 서버는 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.
핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.
이 메시지는 TCP로 보내지기 전에 암호화된다.

### 14.7.4 SSL 핸드셰이크
암호화된 HTTP 메시지를 보낼 수 있데 되기 전에 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.
핸드셰이크에서는 다음과 같은 일이 일어난다.
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

### 14.7.5 서버 인증서
SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다. 그러나 오늘날 흔히 쓰이지는 않는다.
한편 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 
서버인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름 등등을 보여주는 X.509 v3에서 파생된 인증서이다.

### 14.7.6 사이트 인증서 검사
SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하진 않지만
최신 웹브라우저들은 대부분은 인증서에 대해 간단한 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.

넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹 브라우저의 검사 기법의 기초를 구축했다. 수행단계는 아래와 같다.
날짜검사 -> 서명자 신뢰도 검사 -> 서명 검사 -> 사이트 신원 검사

### 14.7.7 가상 호스팅과 인증서
가상 호스트로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 많다.
몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다.
만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다.

## 14.8 진짜 HTTPS 클라이언트
SSL은 복잡한 바이너리 프로토콜이다. 가공되지 않는 SSL 트래픽을 보내서는 안된다.
다행이도 몇몇 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.

### 14.8.1 OpenSSL
OpenSSL은강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 라이브러리이다.

## 14.9 프락시를 통한 보안 트래픽 터널링
클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.
그 예로 많은 회사가 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위한 프락시를 설치한다.

그러나 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면
프락시는 더 이상 HTTP 헤더를 읽을 수 없게 되고 요청을 어디로 보내야 하는지 알 수 없게 된다.
이때 사용하는 인기있는 기법 중 하나가 HTTPS SSL 터널링 프로토콜이다.
HTTPS 터널링 프로토콜을 사용해 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.

 HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해 평문으로 된 종단 정보를 전송하기 위해 사용된다. CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며, 그것이 완료되면 클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있는 터널을 만든다.
