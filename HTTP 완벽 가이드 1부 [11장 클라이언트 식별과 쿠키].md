# 클라이언트 식별과 쿠키
웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.
이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.

## 11.1 개별 접촉
HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
서버는 클라이언트가 보낸 요청을 처리하고 나서 그 응답을 클라이언트로 전송한다.
웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어하기 때문에 네트워크로 연결되 사용자들에 대해 더 많은 것을 알고 싶어 하고 사용자들이 브라우징하는 것을 기록하고 싶어 한다.

***개별 인사***
온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.

***사용자 맞춤 추천***
온라인 상점은 고객의 흥미가 무엇인지 학습해서 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다.

***저장된 사용자 정보***
온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어한다.
이러한 정보를 데이터베이스에 저장하는 온라인 상점도 있다.

***세션 추적***
HTTP 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적으로 일어난다.
많은 웹 사이트에서 사용자가 사이트와 상호 작용할 수 있게 사용자의 상태를 남긴다.
이런 상태를 유지하려면 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.

## 11.2 HTTP 헤더

| 헤더 이름 | 헤더 타입 | 설명 |
|---|:---:|:---:|
| `From` | 요청 | 사용자의 이메일 주소 |
| `User-Agent` | 요청 | 사용자의 브라우저 |
| `Referer` | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| `Authorization` | 요청 | 사용자 이름과 비밀번호 |
| `Client-ip` | 확장(요청) | 클라이언트 IP 주소 |
| `X-Forwarded-For` | 확장(요청) | 클라이언트 IP 주소 |
| `Cookie` | 확장(요청) | 서버가 생성한 ID 라벨 |
위 표는 사용자에 대한 정보를 전달하는 가장 일반적인 일곱가지 HTTP 요청 헤더가 기술되어 있다.

***FROM***
FROM헤더는 사용자의 이메일 주소를 포함한다. 이상적으로는 각 사용자가 서로 다른 이메일 주소를 가지므로 FROM 헤더로 사용자를 식별할 수 있다.
이상적으로는 각 사용자가 서로 다른 이메일 주소를 가져 식별할 수 있지만
실제로는 로봇이나 스파이더가 데이터를 수집하는 과정에서 문제를 일으켰을 때 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 FROM헤더에 이메일 주소를 기술한다.

***User-Agent***
User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보까지 포함하여 서버에게 알려준다.
이는 특정 브라우저에서 제대로 동작하도록 그것들의 속성에 맞추어 콘텐츠를 최적화하는 데 유용할 수 있지만 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다.

***Referer***
Referer 헤더는 사용자가 현재 페이지로 유입하게 한 웹 페이지의 URL을 가리킨다.
Referer 헤더 자체만으로는 사용자를 식별할 수 없지만, 사용자가 이전에 어떤 페이지를 방문했는지 알 수 있어 웹 사용행태나 취향을 더 잘 파악할 수 있다.

## 11.3 클라이언트 IP 주소
초기 웹 선구자들은 사용자 식별에 클라이언트의 IP 주소를 활용하려 했다.
이 방법은 사용자가 확실한 IP 주소를 가지고 있고 그 주소가 불변하며 웹 서버가 요청마다 IP를 알 수 있다면 문제 없이 동작하지만 실제로는 여러 문제점이 있다.
- 클라이언트 IP주소는 사용자가 아닌 사용하는 컴퓨터를 가리킨다.
- 많은 인터넷 서비스 제공자는 사용자가 로그인하면 동적으로 IP 주소를 할당한다.
- 보안을 강화하고 부족한 주소들을 관리하려고 많은 사용자가 네트워크 주소 변환 방화벽을 통해 통해 인터넷을 사용한다.
- 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다 웹 서버는 클라이언트의 IP 주소대신 프락시 서버의 IP 주소를 본다.
## 11.4 사용자 로그인
IP 주소로 사용자를 식별하려는 수동적인 방식보다 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenicate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
한 번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.

하지만 웹 사이트 로그인은 귀찮은 일이다. 다음 절에서 이 문제를 해결하는 방안을 다룰 것이다.

## 11.5 뚱뚱한 URL
어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.
보통 URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
사용자가 그 사이트를 돌아다니면 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 부른다. 
각 URL은 사용자에게 할당된 식별번호를 붙여서 사용자를 추적한다.

웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문'으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다
사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다.

하지만 이 기술에도 몇몇 문제가 있다.
***못생긴 URL***
브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.
***공유하지 못하는 URL***
뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함한다.

***캐시를 사용할 수 없음***
URL로 만드는 것은 URL이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미한다.

***서버 부하 가중***
서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.

***이탈***
사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL세션에서 이탈하기 쉽다.

***세션간 지속성의 부재***
사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상 로그아웃하면 모든 정보를 잃는다.
