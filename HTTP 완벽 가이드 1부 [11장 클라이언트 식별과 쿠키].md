# 클라이언트 식별과 쿠키
웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.
이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.

## 11.1 개별 접촉
HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
서버는 클라이언트가 보낸 요청을 처리하고 나서 그 응답을 클라이언트로 전송한다.
웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어하기 때문에 네트워크로 연결되 사용자들에 대해 더 많은 것을 알고 싶어 하고 사용자들이 브라우징하는 것을 기록하고 싶어 한다.

***개별 인사***
온라인 쇼핑이 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.

***사용자 맞춤 추천***
온라인 상점은 고객의 흥미가 무엇인지 학습해서 고객이 좋아할 것이라고 예상되는 제품들을 추천할 수 있다.

***저장된 사용자 정보***
온라인 쇼핑 고객은 복잡한 주소와 신용카드 정보를 매번 입력하는 것을 싫어한다.
이러한 정보를 데이터베이스에 저장하는 온라인 상점도 있다.

***세션 추적***
HTTP 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적으로 일어난다.
많은 웹 사이트에서 사용자가 사이트와 상호 작용할 수 있게 사용자의 상태를 남긴다.
이런 상태를 유지하려면 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.

## 11.2 HTTP 헤더

| 헤더 이름 | 헤더 타입 | 설명 |
|---|:---:|:---:|
| `From` | 요청 | 사용자의 이메일 주소 |
| `User-Agent` | 요청 | 사용자의 브라우저 |
| `Referer` | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지 |
| `Authorization` | 요청 | 사용자 이름과 비밀번호 |
| `Client-ip` | 확장(요청) | 클라이언트 IP 주소 |
| `X-Forwarded-For` | 확장(요청) | 클라이언트 IP 주소 |
| `Cookie` | 확장(요청) | 서버가 생성한 ID 라벨 |
위 표는 사용자에 대한 정보를 전달하는 가장 일반적인 일곱가지 HTTP 요청 헤더가 기술되어 있다.

***FROM***
FROM헤더는 사용자의 이메일 주소를 포함한다. 이상적으로는 각 사용자가 서로 다른 이메일 주소를 가지므로 FROM 헤더로 사용자를 식별할 수 있다.
이상적으로는 각 사용자가 서로 다른 이메일 주소를 가져 식별할 수 있지만
실제로는 로봇이나 스파이더가 데이터를 수집하는 과정에서 문제를 일으켰을 때 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 FROM헤더에 이메일 주소를 기술한다.

***User-Agent***
User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 운영체제에 대한 정보까지 포함하여 서버에게 알려준다.
이는 특정 브라우저에서 제대로 동작하도록 그것들의 속성에 맞추어 콘텐츠를 최적화하는 데 유용할 수 있지만 특정 사용자를 식별하는 데는 큰 도움이 되지 않는다.

***Referer***
Referer 헤더는 사용자가 현재 페이지로 유입하게 한 웹 페이지의 URL을 가리킨다.
Referer 헤더 자체만으로는 사용자를 식별할 수 없지만, 사용자가 이전에 어떤 페이지를 방문했는지 알 수 있어 웹 사용행태나 취향을 더 잘 파악할 수 있다.

## 11.3 클라이언트 IP 주소
초기 웹 선구자들은 사용자 식별에 클라이언트의 IP 주소를 활용하려 했다.
이 방법은 사용자가 확실한 IP 주소를 가지고 있고 그 주소가 불변하며 웹 서버가 요청마다 IP를 알 수 있다면 문제 없이 동작하지만 실제로는 여러 문제점이 있다.
- 클라이언트 IP주소는 사용자가 아닌 사용하는 컴퓨터를 가리킨다.
- 많은 인터넷 서비스 제공자는 사용자가 로그인하면 동적으로 IP 주소를 할당한다.
- 보안을 강화하고 부족한 주소들을 관리하려고 많은 사용자가 네트워크 주소 변환 방화벽을 통해 통해 인터넷을 사용한다.
- 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다 웹 서버는 클라이언트의 IP 주소대신 프락시 서버의 IP 주소를 본다.
## 11.4 사용자 로그인
IP 주소로 사용자를 식별하려는 수동적인 방식보다 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenicate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
한 번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.

하지만 웹 사이트 로그인은 귀찮은 일이다. 다음 절에서 이 문제를 해결하는 방안을 다룰 것이다.

## 11.5 뚱뚱한 URL
어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.
보통 URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
사용자가 그 사이트를 돌아다니면 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.

사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 부른다. 
각 URL은 사용자에게 할당된 식별번호를 붙여서 사용자를 추적한다.

웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문'으로 묶는 용도로 뚱뚱한 URL을 사용할 수 있다
사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다.

하지만 이 기술에도 몇몇 문제가 있다.
***못생긴 URL***
브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.
***공유하지 못하는 URL***
뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함한다.

***캐시를 사용할 수 없음***
URL로 만드는 것은 URL이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미한다.

***서버 부하 가중***
서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.

***이탈***
사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL세션에서 이탈하기 쉽다.

***세션간 지속성의 부재***
사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키
쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
쿠키가 앞서 기술한 문제점을 겪지는 않지만 쿠키만으로 하기 힘든 일에는 앞에서 설명한 기술들을 사용하기도 한다.

### 11.6.1 쿠키의 타입
쿠키는 크게 **세션쿠키**와 **지속쿠키** 두 가지 타입으로 나눌 수 있다.
세션 쿠키는 사용자가 사이트를 탐색할 때 관련한 설정과 선호 사상들을 저장하는 임시 쿠키다.
세션 쿠키는 부라우저를 닫으면 삭제된다.
지속 쿠키는 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작하더라도 삭제되지 않고 더 길게 유지될 수 있다.
지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.

### 11.6.2 쿠키는 어떻게 동작하는가
쿠키는 서버가 사용자에게 "~~~"라고 적어서 붙이는 스티커와 같다.
사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.
처음 사용자가 웹 사이트에 방문할 때 웹 서버는 사용자에 대해 아무것도 모른다.
웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다. 이 때 쿠키는 임의의 이름=값 형태의 리스트를 가진다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태
쿠키의 기본적인 개념은 브라우저가 서버 관련 정보를 저장하고 사용자가 서버에 접근할 때마다
그 정보를 함께 전송하게 하는 것이다.
브라우저는 쿠키 정보를 저장할 책임이 있는데 이 시스템을 '클라이언트 측 상태' 라고 한다.

### 11.6.4 사이트마다 각기 다른 쿠키
브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.
이유를 알아보자면
- 쿠키를 모두 전달하면 성능이 크게 저하된다
- 쿠키들은 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에 대부분 사이트에서 인식하지 않는 무의미한 값이다.
- 모든 사이트에 쿠키 전체를 전달하는 것은 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어 잠재적인 개인정보 문제를 일으킬 우려가 있다.

**쿠키 Domain 속성**
서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.

**쿠키 Path 속성**
웹 사이트 일부에만 쿠키를 적용할 수도 있다.
URL 앞부부을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전당한다.

### 11.6.8 쿠키와 세션 추적
쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.

### 11.6.9 쿠키와 캐싱
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수도 있다.
다음은 캐시를 다루는 기본 원칙의 예이다.

**캐시되지 말아야 할 문서가 있다면 표시하라**
문서를 캐시하면 될지 안 될지는 문서의 소유자가 가장 잘 안다.
만약 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술해서 명확히 표시한다

**Set-Cookie 헤더를 캐시 하는 것에 유의하라**
만약 응답이 Set-Cookie 헤더를 가지고 있으면 본문은 캐시할 수 있지만
Set-Cookie 헤더를 캐시하는 것은 주의를 기울여야 한다.
같은 Set-Cookie 헤더를 여러 사용자에게 보내면 사용자 추적에 실패할 것이기 때문이다.
어떤 캐시는 응답을 저장하기전 Set-Cookie 헤더를 저장하기 때문에 그 캐시 데이터를 받는 클라이언트는 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
캐시가 모든 요청마다 원 서버가 재검사시켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술해서 이 문제를 개선할 수 있다.

**Cookie 헤더를 가지고 있는 요청을 주의하라**
요청이 Cookie 헤더와 함께 오면 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다.
개인정보는 캐시되지 않도록 표시되어 있어야 하지만 그렇지 않은 서버도 있다.

### 11.6.1. 쿠키, 보안 그리고 개인정보
쿠키를 사용하지 않도록 비활성화시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것도 가능하므로, 그 자체가 보안상으로 엄청나게 위험한 것은 아니다.

개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기에 항상 조심하는 것이 좋다.
쿠키에 대한 부정적인 여론이 많기는 하지만 제공하는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.
