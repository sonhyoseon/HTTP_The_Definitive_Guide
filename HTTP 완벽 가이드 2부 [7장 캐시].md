# 캐시
웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.
웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면 그 문서는 원 서버가 아니라
그 캐시로부터 제공된다.

## 7.1 불필요한 데이터 전송
복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 된다.
똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동하며 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다.

캐시를 사용하면 첫 번째 서버 응답은 캐시에 보관되며 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.

## 7.2 대역폭 방문
캐시는 또한 네트워크 병목을 줄여준다.
많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
클라이언트들이 서버에 접근할 때 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다.
만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것이다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)
캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
갑작스헌 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버에 심각한 장애를 야기시킨다.

## 7.4 거리로 인한 지연
비록 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다.
모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.
기계실 근처에서 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

## 7.5 적중과 부적중
이와 같이 캐시는 유용하다. 그러나 캐시가 세상 모든 문서의 사본을 저장하지는 않는다.
캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있고 그렇지 않다면 원 서버로 요청이 전달될 것이다.
이를 **캐시 적중**과 **캐시 비적중**이라고 부른다

### 7.5.1 재검사
원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
이를 **HTTP 재검사**라 부른다.
효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다.

캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다. 그러나 모든 파일을 재검사하긴 어렵기 때문에 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.

캐시는 캐시된 사본의 재검사가 필요할 때 원 서버에 작은 재검사 요청을 보낸다.
콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보낸다.
해당 사본이 여전히 유효함을 알게된 캐시는 즉각 사본이 신선하다고 임시로 표시한뒤 클라이언트에 제공하며 이를 **재검사 적중**혹은 **느린 적중**이라고 부른다.

이는 원 서버와 검사를 할 필요가 있기 때문에 순수 적중 보다는 느리지만 서버로부터 객체 데이터를 받아올 필요가 없기 때문에 캐시 부적중보다는 빠르다.

HTTP는 캐시된 객체를 재확인 하기 위한 몇 가지 도구를 제공하는데, 그중에서 가장 많이 쓰이는 것은 If-Modified-Since 헤더이다.
서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 사본을 보내달라는 의미가 된다.
If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황에 대해 알아보자

**재검사 적중**
만약 서버 객체가 변경되지 않았다면 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.

**재검사 부적중**
만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.

**객체 삭제**
만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다.

### 7.5.2 적중률
캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률 이라고 부르기도 한다.
적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로 표현되기도 한다.

### 7.5.3 바이트 적중률
문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않는다.
몇몇 큰 객체는 덜 접근되더라고 크기 때문에 전체 트래픽에는 더 크게 기여한다.

바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
이는 트래픽이 절감된 정도를 포착해낸다.

### 7.5.4 적중과 부적중의 구별
불행히도 HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더를 이용하는 것이다.
응답의 Date 헤더 값을 현재 시각과 비교하여 응답이 캐시되었는지 구분할 수 있다.

## 7.6 캐시 토폴로지
캐시는 한 명의 사용자에게만 할당될 수도 있고 여러 사용자들 간에 공유될 수도 있다.
한 명에게만 할당된 캐시를 **개인 전용 캐시**라 부르고
여러 사용자들 간 자주 쓰이는 페이지를 담는 캐시를 **공용 캐시**라 부른다.

### 7.6.1 개인 전용 캐시
개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로 작고 저렴하다.
웹 브라우저가 개인 전용 캐시를 내장하고 있으며 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

### 7.6.2 공용 프락시 캐시
공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버이다.
프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버에 접근한다.
공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

### 7.6.3 프락시 캐시 계층들
작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용한다면 효과적일 것이다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링
몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다. 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내린다.

캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음에 나열된 일들을 모두 할 수 있을 것이다.
- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
- URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜직은 허용하지 않는다.

이러한 복잡한 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다.

## 7.7 캐시 처리 단계
오늘날 상용 프락시 캐시는 꽤 복잡하지만 기본적인 동작은 대개 단순하다.
GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져 있다.
1. 요청 받기 
2. 파싱
3. 검색
4. 신선도 검사
5. 응답 생성
6. 발송
7. 로깅

### 7.7.1 단계 1: 요청 받기
단계 1에서, 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다.
이때 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.

### 7.7.2 단계 2: 파싱
캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다.

### 7.7.3 단계 3: 검색
캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.
로컬 사본이 존재한다면 반환하고 없다면 원 서버나 부모 프락시에서 가져오거나 실패를 반환한다.

### 7.7.4 단계 4: 신선도 검사
HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해준다.
이 기간 동안 문서는 '신선'한 것으로 간주되고 캐시는 서버와 접촉 없이 이 문서를 제공할 수 있다.
그러나 일단 캐시된 사본을 신선도 한계를 넘을 정도로 너무 오래 갖고 있었다면 그 객체는 '신선하지 않은' 것으로 간주되며, 캐시는 변경 여부를 재검사 해야 한다.

### 7.7.5 단계 5: 응답 생성
우리는 캐시된 응답을 원 서버에서 온 것처럼 보이게 하고 싶기 때문에, 캐시는 캐시된 서버 응답헤더를 토대로 응답 헤더를 생성한다.
캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다.
단 Date 헤더를 조정해서는 안 된다는 것에 주의하라

### 7.7.6 단계 6: 전송
일단 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다.
모든 프락시 서버와 마찬가지로 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있다.

### 7.7.7 단계 7: 로깅
대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다.
각 캐시 트랜잭션이 완료된 후 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.

### 7.8 사본을 신선하게 유지하기
캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아니다.
문서는 언제라도 변경될 수 있고 오래된 데이터를 제공하는 캐시는 불필요하다.
HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라고 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 매커니즘을 갖고 있다.
이 매커니즘을 문서 만료와 서버 재검사라고 부른다.

### 7.8.1 문서 만료
HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
캐시 문서가 만료되기 전에는 사본을 제공하지만 만료 후에는 검사 후 문서를 제공한다.

### 7.8.2 유효기간과 나이
서버는 응답 본문과 함께 하는 헤더를 이용해 유효기간을 명시한다.
Cache-Control: max-age를 사용한다면 유효한 시간
Expires를 사용한다면 절대적인 유효기간을 입력한다.

### 7.8.3 서버 재검사
캐시된 문서가 만료되었다는 것이 원 서버에 존재하는 것과 실제로 다르다는 것이 아닌 검사할 시간이 되었음을 뜻한다.
이 검사를 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어볼 필요가 있음을 의미하는 '서버 재검사'라고 부른다.

HTTP 프로토콜은 캐시가 다음 결과중 하나를 반환하길 요구한다.
1. '충분히 신선한' 캐시된 사본
2. 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
3. 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
4. 경고 메시지가 부착된 캐시된 사본(부정확하다면)

### 7.8.4 조건부 메서드와의 재검사
HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.
HTTP는 캐시가 서버에게 '조건부 GET'이라는 요청을 보낼 수 있도록 해준다.
해당 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.

이러한 과정은 GET 요청 메시지에 특별한 조건부 헤더를 추가한 조건부 GET을 활용한다.

### 7.8.5 If-Modified-Since: 날짜 재검사
가장 많이 쓰이는 재검사 헤더는 If-Modified-Since이다.
흔히 'IMS' 요청으로 불리며 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.

If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified헤더와 함께 동작한다.
원 서버는 제공하는 문서에 최근 변경 일시를 붙인다.
캐시가 캐시된 문서를 재검사 하려고 할 때, 캐시된 사본이 마지막으로 수정된 날짜가 담긴
If-Modified-Since 헤더를 포함한다.

컨텐츠가 만약 변경되었다면 최근 변경 일시는 다를 것이고 원 서버는 새 문서를 돌려줄 것이다.
그렇지 않다면 304 Not Modified 응답을 돌려줄 것이다.

### 7.8.6 If-None-Match: 엔티티 태그 재검사
만약 최근 변경 일시 재검사가 적절히 행해지기 어렵다면
If-None-Match 조건부 헤더를 사용할 수 있다.

### 7.8.7 약한 검사기와 강한 검사기
캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔티티 태그를 확인한다. 이 경우, 엔티티 태그와 최근 변경일시는 둘 다 캐시 검사기다.

서버는 때때로 모든 캐시된 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도옥 허용하고 싶은 경우가 있다. 이때 **약한 검사기**를 지원한다.

강한 엔티티 태그는 대응하는 엔티티 값이 어떻게 바뀌던 매번 같이 바뀌어야 하며
약한 엔티티 태그는 대응하는 엔티티에 유의미한 변경이 있을 때마다 같이 변경되어야 한다.

### 7.8.8 언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가?
HTTP/1.1 클라이언트는 만약 서버가 엔티티 태그를 반환했다면 반드시 엔티티 태그 검사기를 사용해야 한다.
만약 서버가 Last-Modified 값만을 반환했다면 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.

HTTP/1.1 원 서버는 실현 불가능하지만 않다면 앤티티 태그 검사기를 보내야 하며, 이점이 있다면 강한 엔티티 태그 대신 약한 엔티티 태그를 보낼 수도 있다.
또한 Last-Modified 값을 같이 보내는 것도 선호된다.

만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔티티 태그 조건부 헤더를 모두 받았다면
요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안된다.

## 7.9 캐시 제어
HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의한다.
우선순위대로 나열해보자면 서버는
- Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
- Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
- Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
- Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.
- Expires 날짜 헤더를 응답에 첨부할 수 있다.
- 아무 만료 정보도 주지 않고, 캐시가 스스로 체험적인 방법으로 결정하게 할 수 있다.

### 7.9.1 no-cache와 no-store 응답 헤더
HTTP/1.1은 신선도를 관리하기 위해 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러 가지 방법을 제공한다.
no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

**no-store**가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지한다.
캐시는 보통 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다'

**no-cache**로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있다.
다만 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

### 7.9.2 Max-Age 응답 헤더
Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고 초로 나타낸다.
또한 s-maxage 헤더는 max-age처럼 행동하지만 공유된(공용) 캐시에만 적용된다.

서버는 최대 나이먹음(maximum aging)을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### 7.9.3 Expires 응답 헤더
더 이상 사용하지 않기를 권하는 Expires 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시한다.

몇몇 서버는 문서를 항상 만료되도록 하기 위해 Expires: 0 응답 헤더를 돌려보내지만
이는 문법 위반이며 몇몇 소프트웨어와 문제를 일으킬 수 있다.
이런 값들은 가급적 받아들일 수는 있어야 하나 생성해서는 안된다.

### 7.9.4 Must-Revalidate 응답 헤더
캐시는 성능을 개선하기 위해 신선하지 않은 객체를 제공하도록 설정될 수 있따,
만약 캐시가 정보를 엄격하게 따르길 원한다면, 원 서버는 다음과 같은 Cache-Control을 붙일 수 있다.
**Cache-Control: must-revalidate**

Cache-Control: must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미한다.
만약 캐시가 must-revalidate 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면,
캐시는 반드시 504 Gateway Timeout error를 반환해야 한다.

### 7.9.5 휴리스틱 만료
만약 응답이 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면
캐시는 경험적인 방법으로 최대 나이를 계산할 것이다.

어떤 알고리즘이든 사용될 수 있지만, 계산 결과 얻은 최대 나이 값이 24보다 크다면
Heuristic Expiration 경고 헤더가 응답 헤더에 추가되어야 한다.

유명한 휴리스틱 만료 알고리즘의 하나인 LM 인자 알고리즘은, 문서가 최근 변경 일시를 포함하고 있다면 사용할 수 있다.
LM 인자 알고리즘은 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용하며 그 로직은 다음과 같다.
- 만약 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 그것은 아마 안정적인 문서일 것이고 갑자기 바뀔 가능성은 별로 크지 않을 것이므로, 캐시에 오래 보관하고 있어도 안전하다.
- 만약 캐시된 문서가 최근에 변경되었다면, 그것은 아마 자주 변경될 것이고, 따라서 우리는 그것을 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다.

### 7.9.6 클라이언트 신선도 제약
웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있다. 이 리프레시 버튼은 Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.

클라이언트는 Cache-Control 요청 헤더를 사용하여 만료 제약을 엄격하게 하거나 느슨하게 할 수 있다.

### 7.9.7 주의할 점
문서 만료는 완벽한 시스템이 아니다.
만약 퍼블리셔가 잘못해서 유효기간을 까마득한 미래로 설정해버린다면 만료되기 전까지는 그 문서에 대한 어떤 변경도 캐시에 반영되지 않을 것이다.

## 7.10 캐시 제어 설정
웹 서버들은 캐시 제어와 만료 HTTP 헤더들은 설정하는 서로 다른 매커니즘을 제공한다.
아파치 웹 서버가 캐시 제어를 어떻게 지원하는지 간략하게 이야기해보자

### 7.10.1 아파치로 HTTP 헤더 제어하기
아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 매커니즘을 제공한다.
이 매커니즘들 중 많은 것이 디폴트로는 가능하지 않게 되어 있어서 사용하려면 일단 활성화시킬 필요가 있다.

**mod_headers**
mod_headers 모듈은 개별 헤더들을 설정할 수 있게 해준다. 한번 이 모듈이 로드되면, 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다.
또한 개별 콘텐츠에 헤더들을 연결시키기 위해 아파치의 정규식과 필터를 조랍하여 사용할 수 있다.

**mod_expires**
mod_expires 모듈은 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다.
이 모듈은 문서에 마지막으로 접근한 날 혹은 수정한 날 이후의 일정 시한으로 유효기간을 설정할 수 있게 해준다.

**mod_cern_meta**
mod_cern_meta 모듈은 HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.
이 모듈을 켜면 제어하고자 하는 파일에 각각 대응되는 메타파일들을 생성하게 되므로
각 메타파일에 원하는 헤더를 추가하면 된다.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어
HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용한다.
웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용 한다.

저자가 웹 서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해, HTML 2.0은 <META HTML-EQUIV> 태그를 정의했다.
이 태그는 HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다.

이 태그는 원래 웹 서버에서 사용되도록 의도 된 것이다.
하지만 불행하게도 이 기능을 지원하는 웹 서버나 프락시는 거의 없다.
이 기능은 서버의 부하를 가중 시키고, 설정 값이 정적이며 HTML을 제외한 다른 타입의 파일은 지원하지 않기 때문이다.

