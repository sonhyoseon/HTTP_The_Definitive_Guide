# HTTP/2.0
HTTP 2.0에 대해 알아보자.
HTTP/2.0의 8번째 초안에 대해 다루다 보니 현재 HTTP/2.0과는 다를 수 있다.

## 10.1 HTTP/2.0의 등장 배경
HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화 되었다.
그러다 보니 성능은 어느 정도 희생시키지 않을 수 없었다.
응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 심각한 회전 지연을 피할 수 없었다.
병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책은 되지 못했다.
2009년 구글이 웹을 더 빠르게 하겠다는 목표아래 SPDY 프로토콜을 내놓았다.
SPDY는 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것이다.
헤더를 압축하여 대역폭을 절약했고 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있다.
HTTP는 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정하였다.

## 10.2 개요
HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작하며 이때 TCP 커넥션을 초기화 하는 것은 클라이언트이다.
요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담기며 이 때 HTTP 헤더는 압축되어 담긴다.
프레임들에 담긴 요청과 응답은 스트림을 통해 보내지며 한 개의 스트림이 한쌍의 요청과 응답을 처리한다.
하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능하다. 이들 스트림에 흐름제어와 우선순위 부여 또한 가능하다.
또한 서버 푸시를 도입해 클라이언트가 필요하다 생각하는 리소스라면 능동적으로 클라이언트에 보내줄 수 있다.

## 10.3 HTTP/1.1 과의 차이점
### 10.3.1 프레임
HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.

프레임 헤더의 각 필드는 다음과 같다.
- R: 예약된 2비트 필드, 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다. 받는 쪽에서는 이 값을 무시한다.
- 길이: 페이로드의 길이를 나타내는 14비트 무부호 정수. 이 길이에 프레임 헤더는 포함되지 않는다.
- 종류: 프레임의 종류.
- 플래그: 8비트 플래그 플래그 값의 의미는 프레임의 종류에 따라 다르다.
- R: 예약된 1비트 필드
- 스트림 식별자: 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임임을 의미한다.

### 10.3.2 스트림과 멀티플렉싱
스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
한 쌍의 HTTP 요청,응답은 하나의 스트림을 통해 이루어진다. 클라이언트는 새 스트림을 만들어 요청을 보내며 응답을 받고 스트림을 닫는다.
HTTP/1.1과는 달리 2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
또한 우선순위도 가질 수 있다.

모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다.
스트림이 클라이언트에 의해 초기화 되었다면 이 식별자는 홀수 이어야 하며
서버라면 짝수여야 한다. 또한 새로 만들어지는 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림의 식별자보다 커야 한다.

스트림은 상대방과 협상 없이 일방적으로 만든다. 이를 통해 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미한다.

### 10.3.3 헤더 압축
HTTP/1.1에서 헤더는 아무런 압축 없이 그래도 전송되었다.
과거와 달리 요즘은 웹 페이지 하나를 보기 위해 수십에서 많으면 수백번의 요청을 보내기 때문에 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.

이를 개선하기 위해 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축해서 전송한다.
헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축한 뒤 '헤더 블록 조각'들로 쪼개져서 전송된다. 받는 쪽에서는 이 조각들은 이은 뒤 압축을 풀어 원래의 헤더 집합을 복원한다.

HPACK은 헤더를 압축하고 해제할 때 '압축 콘텍스트'를 사용한다.

### 10.3.4 서버 푸시
HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다. 이는 클라이언트가 HTML  문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하게 되는 트래픽과 회전 지연을 줄여준다.

리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 한다. 클라이언트가 해당 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에서는 '예약됨' 상태가 된다. 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수도 있다.

이와 같이 사전에 PUSH_PROMISE 프레임을 먼저 보내는 이유는 서버가 푸시하려고 하는 자원을 클라이언트가 별도로 또 요청하게 되는 상황을 피하기 위함이다.
- 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수도 있다.
- 서버는 오직 안전하고 캐시 가능하고 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 한다.
- 마지막으로, 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정하면 된다.
