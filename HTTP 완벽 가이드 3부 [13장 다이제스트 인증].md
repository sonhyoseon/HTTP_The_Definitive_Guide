# 다이제스트 인증
기본 인증은 편리하고 유연하지만 전혀 안전하지 않다.
사용자 이름과 비밀번호를 평문으로 보내고 메시지를 위조하지 못하게 보호하려는 어떠한 시도도 하지 않는다.
다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로서 개발되었다.
다이제스트 인증은 널리 쓰이지는 않지만 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다.

## 13.1 다이제스트 인증의 개선점
다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다.
다이제스트 인증의 특징은 다음과 같다.
- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
- 구현하기에 따라서 메시지 내용 위조를 막는 것도 가능하다.
- 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

다이제스트 인증이 가장 안전한 프로토콜은 아니지만
기본 인증보다 훨씬 강력하다.

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기
다이데스트 인증의 좌우명은 "절대로 비밀번호를 네트워크를 통해 보내지 않는다"이다.
비밀번호를 보내는 대신 클라이언트는 비밀번호를 비가역적으로 뒤섞은 '지문' 혹은 '요약'을 보낸다.

클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.

### 13.1.2 단방향 요약
요약은 '정보 본문의 압축'이다. 요약은 단방향 함수로 동작하고 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.

이 요약에서 중요한 것은 만약 비밀번호를 모른다면 서버에게 보내줄 알맞은 요약을 추측하기 위해 끔찍하게 많은 시간을 소모하게 될 것이라는 것이다.
그리고 요약을 갖고 있다면 거의 무한개의 입력값들 중 그 요약을 생성하는 것을 찾기 위해 끔찍하게 많은 시간을 소모하게 될 것이다.

### 13.1.3 재전송 방지를 위한 난스(nonce) 사용
단방향 요약은 비밀번호를 그대로 전송해야 할 필요성에서 우리를 해방시켜 준다.
우리는 대신 그냥 비밀번호에 대한 요약을 보내주고 악의적인 집단이 쉽게 요약에서 원래 비밀번호를 해독할 수 없음을 보장 받기만 하면 된다.

그러나 요약을 가로챌 수 있지 때문에 서버는 클라이언트에게 난스라고 불리는 특별한 그리고 자주 바뀌는 증표를 건네준다.
난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어준다.

### 13.1.4 다이제스트 인증 핸드셰이크
HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는 강화된 버전의 인증이다. 기존 헤더에 몇몇 새 옵션이 추가되었고 선택적인 헤더인 Authentization-Info가 새로 추가되었다.

## 13.2 요약 계산
다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.
이 요약이 어떻게 계산되는지 알아보자

### 13.2.1 요약 알고리즘 입력 데이터
요약은 다음의 세 요소로부터 계산된다.
- 단방향 해시 함수 H와 요약 함수 KD(s,d). 여기서 s는 비밀, d는 데이터를 의미한다.
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리(A1)
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리(A2)

### 13.2.2 H(d)와 KD(s,d) 알고리즘
다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다.
만약 알고리즘이 정해지지 않았다면 MD5가 기본 값이다.

### 13.2.3 보안 관련 데이터(A1)
A1으로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다. A1은 메시지 자체가 아닌 비밀 정보와만 관련되어 있다.
**MD5**
모든 요청마다 단방향 해시를 실행한다. A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.
**MD5-sess**
사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스를 붙인 것이 A1이 된다.

### 13.2.4 메시지 관련 데이터
A2로 불리는 데이터 덩어리는 URL, 요청 메서드, 메시지 엔티티 본문과 같은 메시지 자체의 정보를 나타낸다.
A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.

RFC 2617은 선택된 보호 수준에 따른 A2의 두 가지 사용법을 정의하고 있다.

- HTTP 요청 메서드와 UR 만 포함 qop="auth"일 때 사용
- 메시지 무결성 검사를 제공하기 위해 메시지 앤티티 본문을 추가 qop="auth-int"일 때 사용

### 13.2.5 요약 알고리즘 전반
RFC 2617은 주어진 H,KD,A1,A2로 요약을 계산하는 두 가지 방법을 정의한다.
- qop 옵션이 빠졌을 때 사용된다. 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
- 난스 횟수 집계 및 대칭 인증의 지원을 포함한다 qop가 'auth'일 때와 'auth-int'일 때 모두 사용된다.

### 13.2.6 다이제스트 인증 세션
어떤 보호 공간을 위한 WWW-Authenticate 인증요구에 대한 클라이언트 응답은 그 보호 공간에 대한 인증 세션을 시작하게 한다.

인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속된다.
클라이언트는 사용자 이름, 비밀번호, 난스, 난스 횟수, 그리고 보호 공간 내 미래의 요청에 들어갈 Authorization 헤더를 만들기 위해 사용될 인증 세션과 연관된 알아보기 힘든 값들을 기억해야 한다.

난스가 만료되면 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.
아니면  서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다.

### 13.2.7 사전 인가
일반적인 인증에서는 각 요청은 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.
만약 클라이언트가 다음 난스가 무엇이 될지 미리 알고 있어서 서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면 이 요청/인증요구 사이클은 생략할 수 있다.

사전 인가는 기본 인증에서는 사소하고 흔한 것이다. 브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라이언트 측 데이터베이스를 관리한다.
사용자가 어떤 사이트에 한번 인증을 하면, 브라우저는 흔히 그 URL에 대한 다음번 요청 때 올바른 Authorization 헤더를 전송한다.

다이제스트 인증에서의 사전 인가는 난스 기술로 인해 더 복잡하다.
서버는 임의의 난스를 생성하기 때문에, 인증요구를 받기 전에는 클라이언트가 올바른 Authorization 헤더인지 알 방법이 없다.

다이제스트 인증은 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇가지 방법을 제안한다.
- 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.
- 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
- 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.

**다음 난스 미리 생성하기**
서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다.
서버는 인증이 성공 했을 때 200 OK 응답과 함께 이 헤더를 미리 보낸다.

사전 인가를 통해 요청/인증요구 사이클에서 벗어날 수 있지만
반면 같은 서버에 다중 요청을 파이프라이닝 하는 능력은 실질적으로 쓸모 없어진다.
다음 요청을 보내지 전에 반드시 다음 난스 값을 받아야 하기 때문이다.

**제한된 난스 재사용**
연속된 난스를 미리 생성하는 것 외의 또 다른 방법은 난스를 제한적으로 재사용 하는 것이다.
이 경우, 클라이언트는 난스를 미리 알 수 있으므로 자유롭게 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝 할 수 있다.
난스를 재사용하면 공격자의 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다.

**동기화된 난스 생성**
제 3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다.

### 13.2.8 난스 선택
난스의 내용은 불투명하고 구현 의존적이다. 그러나 성능 수준, 보안, 편의성은 현명한 선택에 달려있다.
