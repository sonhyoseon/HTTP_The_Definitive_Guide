#  20장 리다이렉션과 부하 균형
HTTP 메시지의 데이터는 수 많은 프로토콜에 의해 통제된다.
이 장에서는 리다이렉션 기술에 대한 장이다.
리다이렉션 기술은 보통 메시지가 프락시, 캐시, 서버 팜의 특정 웹 서버 중 어디에서 끝나는지 판별하기 위해 사용한다.

## 20.1 왜 리다이렉트인가?
리다이렉션은 현대의 웹에선 피할 수 없는 현실이다.
- 신뢰할 수 있는 HTTP 트랜잭션의 수행
- 지연 최소화
- 네트워크 대역폭 절약
위 세가지를 원하기 때문이다.

이러한 이유 때문에 웹 콘텐츠는 흔히 여러 장소에 배포된다.
이렇게 함으로 한곳에서 실패하면 다른 곳을 이용할 수도 있고 클라이언트가 보다 가까운 리소스에 접근할 수 있게된다. 뿐만 아니라 목적지 서버가 분산되므로 네트워크 혼잡도 줄어든다.

리다이렉션의 구현에는 부하 균형의 과제가 포함되는데, 둘은 서로 공존하기 때문이다.

## 20.2 리다이렉트 할 곳
서버, 프락시, 캐시, 게이트웨이는 클라이언트가 그들에게 HTTP 요청을 보내고 그들이 그것을 처리한다는 관점에서 보면 클라이언트에게 있어 모두 서버라고 할 수 있다.

웹 서버는 IP 별로 요청을 다룬다. 똑같이 복제된 서버들로 요청을 분산한다는 것은 같은 URL에 대해 여러곳에서 온 요청들을 각각 최적의 웹 서버로 보내겠다는 것을 의미한다.

프락시는 프로토콜 별로 요청을 다룬다. 이상적으로 프락시 이웃의 모든 HTTP 트래픽은 프락시를 거쳐야 한다.

## 20.3 리다이렉션 프로토콜의 개요
리다이렉션의 목표는 HTTP 메시지를 가용한 웹 서버로 가급적 빨리 보내는 것이다.
HTTP 메시지가 인터넷을 통해 나아가는 방향은 그 메시지가 오고, 거쳐가고, 향하는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.

## 20.4 일반적인 리다이렉션 방법
이 기법들은 트래픽을 다른 서버나 프락시를 통해 벡터 트래픽으로 리다이렉트 하기 위해 사용될 수 있다.

### 20.4.1 HTTP 리다이렉션
웹 서버들은 다른 곳에서 요청을 보내보라고 말해주는 짧은 리다이렉션 메시지를 클라이언트에게 돌려줄 수 있다.
몇몇 웹 사이트는 HTTP 리다이렉션을 이용해 간단하게 부하를 분산한다. 요청을 처리하는 서버는 가용 한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트한다.

웹 서버들이 광범위하게 분산되어 있다며 최선의 가용한 서버를 결정하는것은 어려워 질 것이다.
이 때 HTTP 리다이렉션이 갖는 장점은 리다이렉트 하는 서버가 클라이언트의 아이피 주소를 안다는 것이다.

리다이렉션은 서버로 향하는 요청의 방향을 변경할 수 있지만 다음과 같은 단점이 있다.
- 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 상당히 많은 처리를 해야 한다.
- 페이지에 접근할 때마다 두 번의 왕복이 필요하기 때문에, 사용자가 더 오래 기다리게 된다.
- 리다이렉트 서버가 고장나면 사이트도 고장 난다.

이러한 이유로 HTTP 리다이렉션은 보통 몇몇 다른 리다이렉션 기법과 함께 조합하여 사용한다.

### 20.4.2 DNS 리다이렉션
클라이언트가 웹 사이트에 접근하려 시도할 때 마다 도메인 이름은 반드시 아이피 주소로 분석되어야 한다.
DNS는 하나의 도메인에 여러 아이피의 주소가 결부되는 것을 허용하며 DNS 분석자는 여러 아이피 주소를 반환하도록 설정되거나 프로그래밍 될 수 있다.
분석자가 어떤 아이피 주소를 반환할 것이가를 결정하는 방법은 여러가지가 있다.

**DNS 라운드 로빈**
DNS 라운드 로빈은 가장 흔한 동시에 단순한 리다이렉션 기법이다.
라운드 로빈은 웹 서버 팜 전체에 대하 부하의 균형을 유지하기 위해 DNS 호스트 명 분석 기능을 사용한다.
이것은 순수한 부하 균형 전략이며 서버에 대한 클라이어트의 상대적인 위치나 서버의 현재 스트레스를 고려하지 않는다.

**다중 주소와 라운드 로빈 주소 순환**
대부분의 DNS 클라이언트는 그냥 다중 주소 집합의 첫 번째 주소를 사용한다.
부하 균형을 위해 대부분의 DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다.

**부하 균형을 위한 DNS 라운드 로빈**
대부분의 DNS 클라이언트는 그냥 첫 번째 주소를 사용하기 때문에 DNS 순환은 서버들 간의 부하 균형을 유지해준다.  이 때문에 라운드 로빈 순환으로 부하 균형을 유지시킨다.

**DNS 캐싱의 효과**
DNS 주소 순환은 부하를 순환시킨다. 그러나 이 부하 균형은 완벽하지 않은데 DNS 룩업의 결과는 재사용 될 수 있기 때문이다.
호스트 하나에 대해 한번의 룩업을 수행한 뒤 그 주소를 몇 번이고 다시 사용한다면 비용을 줄일 순 있지만 하나의 클라이언트로 인한 부하를 제대로 분산하지 못한다.

그러나 비록 DNS가 단일 클라이언트의 트랜잭션을 서버의 복제들에게 나눠주지 않더라도 그것은 여러 클라이언트들의 부하 총량을 분산하는 적절한 작업을 수행한다.

**다른 DNS 기반 리다이렉션 알고리즘**
몇몇 향상된 DNS 서버는 주소의 순서를 결정하기 위해 다른 기법들을 사용한다.
**부하 균형 알고리즘**
몇몇 DNS 서버는 웹 서버의 로드를 추적하고 가장 로드가 적은 웹 서버를 목록의 가장 위에 놓는다.

**근접 라우팅 알고리즘**
웹 서버들의 팜이 지리적으로 분산되어 있는 경우, DNS 서버는 사용자를 근처의 웹 서버로 보내는 시도를 할 수 있다.

**결함 마스킹 알고리즘**
DNS 서버는 네트워크의 건강 상태를 모니터링하고 요청을 정전이나 기타 장애를 피해서 라우팅 할 수 있다.

### 20.4.3 임의 캐스트 어드레싱
임의 캐스트 어드레싱에서, 여러 지리적으로 흩어진 웹 서버들은 정확히 같은 아이피 주소를 갖고 클라이언트의 요청을 클라이언트에서 가장 가까운 서버로 보내기 위해 백본 라우터의 최단거리 라우팅 능력에 의존한다.

이 방식이 동작하는 방식 중 하나는 각 웹 서버에게 자신을 인접한 백본 라우터를 향하는 라우터라고 광고하는 것이다.
웹 서버는 라우터 통신 프로토콜을 이용해 자신과 인접한 백본 라우터와 대화한다.
백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때 그것은 그 아이피 주소를 받아들일 수 있는 가장 가까운 라우터를 찾는다.

### 20.4.4 아이피 맥 포워딩
이더넷 네트워크에서 HTTP 메시지는 주소가 붙은 데이터 패킷의 형태로 보내진다.
각 패킷은 출발지와 목적지의 아이피 주소와 TCP 포트번호로 이루어진 레이어-4 주소를 갖고 있다.
또한 레이어-2 장비가 주의를 기울여야 하는 레이어-2 주소인 미디어 접근 컨트롤 주소도 갖고 있다.(레이어-2 장비의 역할은 들어오는 맥 주소의 패킷을 받아서 나가는 특정 맥 주소로 포워딩 하는 것이다.)
레이어-4를 이해하는 스위치는 레이어-4 주소를 검사하여 이 정보에 근거해 라우팅을 할 수 있다.

### 20.4.5 아이피 주소 포워딩
아이피 주소 포워딩에서, 스위치나 다른 레이어 4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다. 
맥 포워딩보다 좋은 점은 스위치에서 업스트림의 위치를 판별할 수만 있으면 일반적인 레이어-3 종단간 인터넷 라우팅이 패킷을 올바른 위치로 보내준다.

그러나 여기엔 라우팅 대칭성이라는 문제가 있다. 클라이언트로부터 들어오는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있다. 스위치는 그 커넥션을 통해 클라이언트에게 응답을 돌려주어야 하므로 목적지 서버나 프락시로부터의 모든 응답은 반드시 그 스위치에게 돌아가야 한다.

응답의 귀환 경로를 제어할 수 있는 두 가지 방법은 다음과 같다.
- 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 변경
- 만약 출발지 아이피 주소가 그 클라이언트의 아이피 주소로 계속 남아있다면 서버에서 클라이언트로 바로 가는 경로가 존재하지 않아야한다.

### 20.4.6 네트워크 구성요소 제어 프로토콜
네트워크 구성요소 제어 프로토콜(NECP)은 아이피 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소(NE)들이 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성요소(SE)들과 대화할 수 있게 해준다.
SE는 NE에게 부하 균형 정보를 제공할 수 있는 방법을 제공하며, SE가 적합하다 판단한 대로 NE가 부하 균형을 유지할 수 있도록 한다.
NECP는 예외에 대한 개념을 지원한다. SE는 특정 출발지 아이피 주소가 서비스할 수 없다고 판단할 수 있으며, 그러한 경우 그 주소들을 NE로 보낼 수 있다. 그러면 NE는 그 아이피 주소로부터의 요청을 원 서버로 전달할 수 있다.

## 20.5 프락시 리다이렉션 방법
우리가 지금까지 일반적인 리다이렉션 방법들에 대해 알아보았다.
콘텐츠에 접근할 때 프락시를 통할 필요가 있는 경우도 있으며
클라이언트가 이용하면 유익한 프락시 캐시가 네트워크에 있을 수 있다.

이 때 웹브라우저와 같은 클라이언트들이 프락시로 가는 길을 아는 방법은
- 명시적인 브라우저 설정
- 동적인 자동 설정
- 자연스러운 가로채기
세 가지가 있다.

프락시는 결과적으로 클라이언트의 요청을 다른 프락시로 리다이렉트할 수 있다.

### 20.5.1 명시적 브라우저 설정
대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴가 존재한다. 사용자가 이를 설정하면 브라우저는 모든 요청에 대해 프락시와 접촉한다.
이런 명시적 브라우저 설정에는 두 가지 단점이 있다.
- 프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않는다.
- 네트워크 아키텍쳐를 변경했을 때 그 변경사항을 모든 최종사용자에게 전파하는것이 어렵다.

### 20.5.2 프락시 자동 설정
특정 프락시에 접촉하기 위한 브라우저의 명시적인 설정은 네트워크 아키텍처의 변화를 제한하기 때문에 동적으로 자신을 설정할 수 있게 하는 자동 설정 방법으로 이 문제를 해결했다.

### 20.5.3 웹 프락시 자동발견 프로토콜
웹 프락시 자동발견 프로토콜은 최종 사용자가 수동으로 프락시 설정을 할 필요도 투명한 트래픽 인터셉트에 의존할 필요도 없이 웹브라우저가 근처에 프락시를 찾아내어 사용할 수 있게 해주는 방법을 제공하는 것을 목적으로 하고 있다.

**PAC 파일 자동 발견**
WAPD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 그 파일을 이용해서 적절한 프락시 서버의 이름을 알아낼 수 있게 해준다.
PAC 파일에 의해 제공되는 추가적인 기능들을 활용하기 위해 직접적으로 프락시 서버의 이름을 알아내지는 않는다.

**WAPD 알고리즘**
WAPD는 적절한 PAC 파일 CURL을 결정하기 위해 여러 가지 리소스 발견 기법들을 사용한다.
모든 조직이 모든 기법을 사용할 수 있는 것은 아니기 때문에 여러 발견 기법들이 지정된다.
WAPD 클라이언트는 CURL을 얻는데 성공할 때까지 각각의 기법을 하나씩 사용한다.
- DHCP
- SLP
- DNS에게 잘 알려진 호스트 명
- DNS의 SRV 레코드
- TXT 레코드의 DNS 서비스 URL들
이 다섯가지 매커니즘 중에서 WAPD 클라이언트에게는 오직 DHCP와 DNS에게 잘 알려진 호스트 명 기법만이 요구된다.

**DHCP를 이용한 CURL 발견**
이 매커니즘이 동작하려면 WAPD 클라이언트가 질의하는 DHCP 서버는 반드시 CURL을 저장하고 있어야 한다. WPAD 클라이어트는 DHCP 질의를 DHCP 서버에 보냄으로써 CURL을 얻는다.

**DNS A 레코드 룩업**
이 매커니즘이 동작하려면, 알맞은 프락시 서버의 IP 주소들이 WAPD 클라이언트들이 질의할 수 있는 DNS 서버에 반드시 저장되어 있어야 한다
WPAD 클라이언트는 A 레코드 룩업을 DNS 서버로 보내 CURL을 얻는다. 룩업이 성공하면 적절한 프락시 서버의 IP 주소를 얻는다.

**PAC 파일 가져오기**
한번 후보 CURL이 생성되면, WAPD 클라이언트는 보통 그 CURL로 GET 요청을 만드는데 이때 자신이 다룰 수 있는 적절한 CFILE 포맷 정보가 담긴 Accept 헤더를 포함해야 한다

**언제 WPAD를 실행하는가**
웹 프락시 자동발견 프로세스는 적어도 다음 중 하나의 상황에서는 수행되어야 한다
- 웹 클라이언트가 시작될 때
- 클라이언트 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때마다.

**WAPD 스푸핑**
WPAD의 IE 5 구현은 사용자의 개입 없이 웹 클라이언트가 프락시 설정을 자동으로 탐지하는 것을 가능하게 했다.
WPAD의 알고리즘은 호스트 명 'wpad'를 도메이 이름의 절대 표기 앞에 붙이고 WPAD 서버를 찾아내거나 3차 도메인에 도달할 때까지 계속해서 서브 도메인을 지운다.

**타임아웃**
WPAD는 여러 발견 단계를 거치게 되며 클라이언트는 각 단계가 일정한 시간 내에 끝나는지 반드시 확인해야 한다.

**관리자를 위한 고려사항**
클라이언트들이 호환을 위해 반드시 구현해야 하는 것은 DHCP와 DNS A 레코드 검색 뿐이다.
이와 마찬가지로 관리자들 역시 그들의 환경에 이 둘 중 하나를 설정해야 한다.

## 20.6 캐시 리다이렉션 방법
캐싱 프락시 서버를 위해 사용되는 보다 복잡한 리다이렉셔 기법 중 몇 가지에 대해 알아보자

### 20.6.1 WCCP 리다이렉션
WCCP는 라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다.

**WCCP 리다이렉션 동작**
다음은 WCCP 리다이렉션이 HTTP를 위해 어떻게 동작하는지에 대한 간략한 개요다.
- 네트워크가 필요하다.
- 라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다
- 만약 서비스 그룹이 HTTP 트래픽을 리다이렉션하도록 설정되어 있다면 서비스 그룹의 라우터는 HTTP 요청을 서비스 그룹의 캐시로 보낸다.
- HTTP 요청이 서비스 그룹의 라우터에 도착했을 때 라우터는 그 요청을 처리하기 위해 서비스 그룹의 캐시 중 하나를 선택한다.
- 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩을 하여 캐시로 보낸다.
- 만약 캐시가 요청을 처리할 수 없다면, 패킷은 평범하게 포워딩되기 위해 라우터로 돌아온다.
- 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지를 교환한다.

**메시지 구성요소**
각 WCCP2 메시지는 헤더와 구성요소로 되어있다.
WCCP 헤더 정보는 메시지의 종류, WCCP 버전, 메시지의 길이를 포함한다.
각 구성요소는 그 구성요소의 종류와 길이를 서술하는 4바이트 헤더로 시작한다.

**서비스 그룹**
서비스 그룹은 WCCP를 지원하는, 그래서 WCCP 메시지를 교환할 수 있는 라우터와 캐시들의 집합으로 구성되어 있다.

**GRE 패킷 캡슐화**
WCCP를 지원하는 라우터들은 HTTP 패킷을 특정 서버의 IP 주소와 함께 캡슐화 함으로써 그 서버로 리다이렉트 한다.
이 패킷 캡슐화는 일반 라우터 캡슐화임을 나타내는 IP 헤더 proto 필드도 포함하고 있다.

**WCCP 부하 균형**
WCCP 라우터는 라우팅뿐만 아니라 여러 수신 서버 간의 부하 균형을 유지할 수 있다.
WCCP 라우터와 그들의 수신 서버들으 그들이 살아 있고 동작 중임을 다른 장비들이 알 수 있도록 하트비트 메시지를 서로 교환한다.

## 20.7 인터넷 캐시 프로토콜
인터넷 캐시 프로토콜(ICP)는 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있도록 해준다.
만약 캐시가 HTTP 메시지에서 요청한 콘텐츠를 갖고 있지 않다면, 캐시는 근처의 형제 캐시 중 그 콘텐츠를 갖고 있는 것이 있는지 찾아보고 만약  있다면 원 서버에 질의하는 것보다 비용이 더 들지 않을 것을 기대하며 그 캐시에서 콘텐츠를 가져온다.
ICP는 일종의 캐시 클러스터링 프로토콜이라고 할 수 있다.

한차례 이상 ICP 질의를 통해 HTTP 요청 메시지의 최종 목적지를 결정할 수 있다는 점에서 이 프로토콜은 리다이렉션 프로토콜이다.

ICP는 객체 발견 프로토콜이다. 캐시는 이 프로토콜을 사용해 근처의 캐시 모두에게 특정 URL을 갖고 있는지 한번에 물어본다.

ICP는 단순하고 가볍다. ICP 메시지는 파싱하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크기로 맞추어진 구조체이다.

## 20.8 캐시 배열 라우팅 프로토콜
프락시 서버는 사용자 개개인으로부터의 요청을 가로채어 요청한 웹 객체의 캐시된 사본을 제공함으로써 인터넷으로 향하는 트래픽을 대폭 줄여준다.
그러나 사용자에 증가에 따라 대량의 트래픽은 프락시 서버 자체에 과도한 부하를 줄 수 있다.
이 문제에 대한 해결책 중 하나는 부하를 분산하기 위해 사용하는 프락시 서버를 여러대로 늘리는 것이다.
