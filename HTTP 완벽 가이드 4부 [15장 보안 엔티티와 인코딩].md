# 엔티티와 인코딩
HTTP는 수 많은 미디어 객체를 실어 나른다.
이때 HTTP는 메시지가 올바르게 수송되고 식별되고 추출되고 처리되는 것을 보장한다.

이를 가능하게 하기 위해, HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔티티를 사용한다.
이 장에서는 해당 내용에 대해 다룰 것이다.

## 15.1 메시지는 컨테이너 엔티티는 화물
HTTP 메시지를 인터넷 운송시스템의 컨테이너라 생각하면 엔티티는 메시지의 화물이다.

HTTP 엔티티 헤더는 HTTP 메시지의 내용물을 설명한다.
HTTP/1.1의 10가지 주요 엔티티 헤더 필드를 알아보자
Content-Type
엔티티에 의해 전달된 객체의 종류

Content-Length
전달되는 메시지의 길이나 크기

Content-Language
전달되는 객체와 가장 잘 대응되는 자연어

Content-Encoding
객체 데이터에 대해 행해진 변형

Content-Location
요청 시점을 기준으로 객체의 또 다른 위치

Content-Range
만약 이 엔티티가 부분 엔티티라면 이 헤더는 이 엔티티가 전체에서 어느 부분에 해당하는지 정의

Content-MD5
엔티티 본문의 콘텐츠에 대한 체크섬

Last-Modified
서버에서 이 콘텐츠가 생성 혹은 수정된 날

Expires
이 엔티티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각

Allow
이 리소스에 대해 어떤 요청 메서드가 허용되는지

ETag 
이 인스턴스에 대한 고유한 검사기 엄밀히 말해 ETag 헤더는 엔티티 헤더로 정의되어 있지는 않지만
엔티티와 관련된 많은 동작을 위해 중요한 헤더이다.

Cache-Control
어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

### 15.1.1 엔티티 본문
엔티티 본문은 가공되지 않은 데이터만을 담고 있다.
다른 정보들은 모두 헤더에 담겨있다.
엔티티 본문은 가공되지 않은 데이터이기 때문에 엔티티 헤더를 통해 그 데이터의 의미에 대해 설명한다.

엔티티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

## 15.2 Content-Length: 엔티티의 길이
Content-Length 헤더는 메시지의 엔티티 본문의 크기를 바이트 단위로 나타낸다.
어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.
위 해더는 메시지를 청크 인코딩으로 전송하지 않는 이상 필수적으로 있어야 한다.

### 15.2.1 잘림 검출
클라이언트는 메시지의 잘림의 검출하기 위해 Content-Length를 필요로 한다.
Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지 전송중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

### 15.2.2 잘못된 Content-Length
Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다.
몇몇 클라이너트 서버 프락시 들은 서버가 오동작을 했는지 탐지하고 교정을 시도한다.

### 15.2.3 Content-Length와 지속 커넥션
Content-Length는 지속 커넥션을 위해 필수적이다.
만약 응답이 지속 커넥션을 통해서 온 것 이라면 또 다른 응답이 즉시 뒤를 이을 것이다.
Content-Length 헤더는 메시지가 어디서 끝나고 다음 시작은 어디인지 알려주기 때문에 필수적이다.

### 15.2.4 콘텐츠 인코딩
HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔티티 본문을 인코딩할 수 있게 해준다.
만약 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.

### 15.2.5 엔티티 본문 길이 판별을 위한 규칙
1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는 본문 계산을 위한 Content-Length 헤더가 무시된다.
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔티티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
3. 메시지가 Content-Length 헤더를 갖는다면 Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔티티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다. 이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔티티 본문 유형이다. 따라서 이 미디어 타입은 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지는 절대로 보내지 말아야 한다.
5. 위의 어떤 규칙에도 해당되지 않는다면 엔티티는 커넥션이 닫힐 때 끝난다.
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔티티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

## 15.3 엔티티 요약
HTTP가 일반적으로 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 여러 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
의도치 않은 변형을 감지하기 위해 송신자는 데이터에 대한 체크섬을 생성할 수 있으며
수신자는 의도치 않은 변경을 잡아내기 위해 기본적인 검사를 할 수 있다.

Content-MD5 헤더는 서버가 엔티티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다.

메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

## 15.4 미디어 타입과 차셋
Content-Type 헤더 필드는 엔티티 본문의 MIME 타입을 기술한다.
MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.

Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME이다.
MIME 타입은 주 미디어 타입으로 시작해서 뒤이어 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성된다.
  |명칭|엔터티 본문|
  |---|---|
  |text/html| HTML 문서|
  |text/plain| 플레인 텍스트 문서|
  |mage/gif| GIF 이미지|
  |mage/jpeg| JPEG 이미지|
  |audio/x-wav| WAV 음향데이터|
  |model/vrml| 삼차원 VRML 모델|
  |application/vnd.ms-powerpoint| MS 파워포인트 프레젠테이션|
  |multipart/byteranges| 전체 문서의 특정 범위(Byte 단위) 담은 여러 부분으로 나뉨 |
  |message/http| 완전한 HTTP 메세지 (6장의 TRACE 메소드 참고)|
  
### 15.4.1 텍스트 매체를 위한 문자 인코딩
Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
엔티티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 그 대표적인 예이다.

### 15.4.2 멀티파트 미디어 타입
MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며 하나의 복합 메시지로 보내진다. 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함하며, 여러 구성요소들이 이어져 있고 문자열 하나로 서로의 경계가 식별된다.

### 15.4.3 멀티파트 폼 제출
HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다. 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.

### 15.4.4 멀티파트 범위 응답
범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다.
그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

## 15.5 콘텐츠 인코딩
HTTP 애플리케이션은 암호화 혹은 전송시간을 줄이기 위해 콘텐츠를 보내기 전에 인코딩을 하려고 한다.
이러한 종류의 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다.

### 15.5.1 콘텐츠 인코딩 과정
콘텐츠 인코딩 과정은 다음과 같다.
1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩 할 수 있도록 한다.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형
HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다. 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.
  |명칭|무손실 압축|상세|
    |---|---|---|
    |gzip|o| GNU zip 인코딩 적용됨 <br> (효율적이고 널리 사용되는 압축 알고리즘)|
    |compress|o|compress가 실행됨 <br> (유닉스의 파일압축 프로그램)|
    |deflate|o|zlib 포맷으로 압축됨|
    |identity|x|- 어떤 인코딩도 적용 안 됨 <br> - Content-Encoding 없는 경우 이 값으로 간주|
gzip,compress,deflate 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.

### 15.5.3 Accept-Encoding 헤더
우리는 클라이언트가 해독할 수 없는 방법으로 서버가 콘텐츠를 인코딩하는 것을 원하지 않는다.
이를 방지하기 위해 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.

클라이언트는 각 인코딩에 Q값을 매개변수로 더해 선호도를 나타낼 수 있다.(0.0-1.0)

## 15.6 전송 인코딩과 청크 인코딩
콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연결되어 있다.
텍스트 파일은 흔히 gzip으로 압축하지만 jpeg 파일은 gzip으로 압축되지 않는다.

메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.

### 15.6.1 안전한 전송
전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 **안전한 전송**을 위해 존재했다.
HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다.

**알 수 없는 크기**
몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다.
그리고 서버는 사이즈를 알기 전 데이터 전송을 시작하려 한다.

HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.

**보안**
공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다.
하지만 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다.

### 15.6.2 Transfer-Encoding 헤더
전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두개 뿐이다.

**Transfer-Encoding**
안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.

**TE**
어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.
TE 헤더는 Accept-Encoding 헤더와 마찬가지로 어떤 형태의 전송 인코딩 선호하는지 표현하는 Q 값을 가질 수 있다.
그러나 Q 값이 0.0을 갖는 것을 허용하지는 않는다.

### 15.6.3 청크 인코딩
청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.
청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.
본문이 동적으로 생성됨에 따라 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있다. 본문 전체를 보낼 때까지 이 단계를 반복한다.

청크 인코딩은 전송 인코딩의 한 형태이며 따라서 본문이 아닌 메시지의 속성임을 주목할 필요가 있다.

**청크와 지속 커넥션**
클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다. 클라이언트는 서버가 커넥션을 닫을 때까지를 본문으로 간주하고 읽을 것이다.
지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다. 콘텐츠가 서버에서 동적으로 생성되는 경우에는 보내기 전에 본문의 길이를 알아내는 것이 불가능할 것이다.

청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해법을 제공한다. 동적으로 본문이 생성되며 이 중 일부분을 버퍼에 담아 버퍼의 크기와 함께 보낸다.
사이즈가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.

**청크 인코딩된 메시지의 트레일러**
다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.
- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
트레일러에는 본문의 콘텐츠가 먼저 생성되어야 한다거나 하는 등의 이유로 메시지 시작 지점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.

### 15.6.4 콘텐츠와 전송 인코딩의 조합
콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

### 16.6.5 전송 인코딩 규칙
전송 인코딩이 메시지 본문에 적용될 때 몇 가지 규칙이 반드시 적용되어야 한다.
- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.
이 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 해준다.

## 15.7 시간에 따라 바뀌는 인스턴스
웹 객체는 수시로 바뀐다. 홈페이지를 객체라 하고 그것의 각각 다른 버전을 다른 인스턴스라 생각하면 시간에 따라 클라이언트는 다른 인스턴스를 받을 수 있다.

HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데 이것은 인스턴스 조작이라 불리며 객체의 인스턴스에 작용한다.

## 15.8 검사기와 신선도
15.7 에서 클라이언트는 최초로 리소스를 받을 때 이 사본을 캐시한다.
이 때 얼마나 오랫동안 캐시해야 할까?
조건부 요청이라 불리는 이 특별한 요청은 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내 달라고 요청하는 것이다. 세가지 주요 개념(신선도, 검사기, 조건)에 대해 알아보자

### 15.8.1 신선도
서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다.
서버는 Expires나 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있다.
Expires 헤더는 문서가 만료되어 더 이상 신선하다고 간주할 수 없게 되는 정확한 날짜를 명시한다.
이 헤더를 올바르게 사용하기 위해서는 시계를 반드시 동기화 하여야 한다.

Cache-Control 헤더는 서버와 클라이언트 양쪽에서 더 많은 지시자들과 함께 수명이나 유효기간뿐 아니라 선도를 서술하기 위해 사용된다.

### 15.8.2 조건부 요청과 검사기
캐시의 사본이 요청되었을때 그것이 신선하지 않다면 신선한것으로 만들 필요가 있다.
캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같을 것이다. 캐시 된 사본은 만료될 수 있지만 여전히 자료는 서버의 자료와 같다. 
만약 이때 계속 문서를 가져온다면 대역폭을 낭비하는 것이다.

이를 해결하기 위해 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다.
조건부 요청은 평범한 HTTP 요청 메시지이지만 특정 조건이 참일 때에만 수행된다.
조건부 요청은 'if-'로 시작하는 조건부 헤더에 의해 구현된다. 조건이 참이 아니라면 에러코드를 돌려보낸다.

HTTP는 검사기은 약한 검사기와 강한 검사기 두 가지로 분류한다.
약한 검사기는 인스턴스를 고유하게 식별하지 못하는 경우도 있지만
강한 검사기는 언제나 고유하게 식별한다.

클라이언트와 서버는 때때로 엔티티 태그 검사를 통화하지 못한 버전을 채택하는 경우가 있다.
작은 수정으로 굳이 대량 전송을 유발하지 않기를 희망할 땐 태그 앞에 'W/'를 붙임으로써 '약한' 엔티티 태그임을 알린다.

## 15.9 범위 요청
HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.
어느 파일을 다운로드 할 때 절반만 다운로드 되었다 가정하면 나머지 데이터를 이어서 받는 편이 유리할 것이다.
범위 요청을 이용하면 HTTP 클라이언트는 받다가 실패한 엔티티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.
Range 헤더는 또한 여러 범위로 요청을 하기 위해 사용될 수 있다.

## 15.10 델타 인코딩
만약 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만 서버가 전송한다면 클라이언트는 더 빠르게 페이지를 얻을 수 있을 것이다.

델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는 HTTP 프로토콜의 확장이다.
델타 인코딩은 일종의 인스턴스 조작이다. 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문이다.

1. 클라이언트는 페이지의 어떤 버전을 갖고 있는지 말해주어야 한다.
2. 클라이언트는 서버에 자신이 현재 버전의 델타를 적용하기 위해 어떤 알고리즘을 알고 있는지 말해준다.
3. 서버는 자신이 클라이언트가 갖고 있는 버전을 갖고 있는지, 그리고 어떻게 최신 버전과 클라이언트의 버전 사이의 델타를 계산할 것인지 체크한다.
4. 그 후 델타를 계산해 클라이언트에게 보내주고 서버가 델타를 보내고 있음을 클라이언트에게 알려주고 페이지의 최신 버전에 대한 새 식별자를 명시해야 한다.

클라이언트는 자신이 갖고 있는 버전에 대한 유일한 식별자를 If-None-Match 헤더에 담는다.
이것은 서버의 최신 버전 페이지가 이것과 같은 ETag를 갖고 있지 않다면 최신 버전의 페이지를 보내달라 말하는 클라이언트의 방식이다.
그러나 클라이언트는 서버에게 A-IM 헤더를 보내거 자신이 페이지에 대한 델타를 받아들일 수 있음을 알려줄 수도 있다.

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기
클라이언트는 A-IM 헤더를 사용해서 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다.
|명칭|상세|
  |---|---|
  |vcdiff|vcdiff 알고리즘 이용한 델타 <br> diff 알고리즘보다 강력해서 텍스트 파일 외에도 적용 가능 <br> 일반적으로 diff -e 보다 더 작은 델타 생성|
  |diffe|유닉스의 diff -e 명령 사용한 델타 <br> 유닉스 ed 편집기 사용해 델타 적용 가능 <br> 파일에 대한 줄 단위 비교 수행 => 바이너리 파일에 이용 불가|
  |gdiff|gdiff 알고리즘 이용한 델타|
  |gzip|gzip 알고리즘 이용한 압축 |
  |deflate|deflate 알고리즘 이용한 압축|
  |range|현재 응답이 범위선택에 대한 결과(partial 콘텐츠)임을 안내하기 위한 서버 응답|
  |identity|클라이언트가 identity 인스턴스 조작 수용의사 있음 안내하기 위한 클라이언트 요청 <br>A-IM 헤더에서 사용|

델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 까다로울 수 있다.
변경이 잦고 많은 사람이 접근하는 페이지에서는 델타 인코딩을 지원하는 서버는 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모두 유지하고 있어야 한다.
