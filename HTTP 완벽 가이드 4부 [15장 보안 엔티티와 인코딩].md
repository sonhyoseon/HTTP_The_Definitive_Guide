# 엔티티와 인코딩
HTTP는 수 많은 미디어 객체를 실어 나른다.
이때 HTTP는 메시지가 올바르게 수송되고 식별되고 추출되고 처리되는 것을 보장한다.

이를 가능하게 하기 위해, HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔티티를 사용한다.
이 장에서는 해당 내용에 대해 다룰 것이다.

## 15.1 메시지는 컨테이너 엔티티는 화물
HTTP 메시지를 인터넷 운송시스템의 컨테이너라 생각하면 엔티티는 메시지의 화물이다.

HTTP 엔티티 헤더는 HTTP 메시지의 내용물을 설명한다.
HTTP/1.1의 10가지 주요 엔티티 헤더 필드를 알아보자
Content-Type
엔티티에 의해 전달된 객체의 종류

Content-Length
전달되는 메시지의 길이나 크기

Content-Language
전달되는 객체와 가장 잘 대응되는 자연어

Content-Encoding
객체 데이터에 대해 행해진 변형

Content-Location
요청 시점을 기준으로 객체의 또 다른 위치

Content-Range
만약 이 엔티티가 부분 엔티티라면 이 헤더는 이 엔티티가 전체에서 어느 부분에 해당하는지 정의

Content-MD5
엔티티 본문의 콘텐츠에 대한 체크섬

Last-Modified
서버에서 이 콘텐츠가 생성 혹은 수정된 날

Expires
이 엔티티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각

Allow
이 리소스에 대해 어떤 요청 메서드가 허용되는지

ETag 
이 인스턴스에 대한 고유한 검사기 엄밀히 말해 ETag 헤더는 엔티티 헤더로 정의되어 있지는 않지만
엔티티와 관련된 많은 동작을 위해 중요한 헤더이다.

Cache-Control
어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

### 15.1.1 엔티티 본문
엔티티 본문은 가공되지 않은 데이터만을 담고 있다.
다른 정보들은 모두 헤더에 담겨있다.
엔티티 본문은 가공되지 않은 데이터이기 때문에 엔티티 헤더를 통해 그 데이터의 의미에 대해 설명한다.

엔티티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

## 15.2 Content-Length: 엔티티의 길이
Content-Length 헤더는 메시지의 엔티티 본문의 크기를 바이트 단위로 나타낸다.
어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.
위 해더는 메시지를 청크 인코딩으로 전송하지 않는 이상 필수적으로 있어야 한다.

### 15.2.1 잘림 검출
클라이언트는 메시지의 잘림의 검출하기 위해 Content-Length를 필요로 한다.
Content-Length가 없다면 커넥션이 정상적으로 닫힌 것인지 메시지 전송중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

### 15.2.2 잘못된 Content-Length
Content-Length가 잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다.
몇몇 클라이너트 서버 프락시 들은 서버가 오동작을 했는지 탐지하고 교정을 시도한다.

### 15.2.3 Content-Length와 지속 커넥션
Content-Length는 지속 커넥션을 위해 필수적이다.
만약 응답이 지속 커넥션을 통해서 온 것 이라면 또 다른 응답이 즉시 뒤를 이을 것이다.
Content-Length 헤더는 메시지가 어디서 끝나고 다음 시작은 어디인지 알려주기 때문에 필수적이다.

### 15.2.4 콘텐츠 인코딩
HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔티티 본문을 인코딩할 수 있게 해준다.
만약 본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.

### 15.2.5 엔티티 본문 길이 판별을 위한 규칙
1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는 본문 계산을 위한 Content-Length 헤더가 무시된다.
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔티티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
3. 메시지가 Content-Length 헤더를 갖는다면 Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔티티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다. 이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔티티 본문 유형이다. 따라서 이 미디어 타입은 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지는 절대로 보내지 말아야 한다.
5. 위의 어떤 규칙에도 해당되지 않는다면 엔티티는 커넥션이 닫힐 때 끝난다.
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔티티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

## 15.3 엔티티 요약
HTTP가 일반적으로 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 여러 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
의도치 않은 변형을 감지하기 위해 송신자는 데이터에 대한 체크섬을 생성할 수 있으며
수신자는 의도치 않은 변경을 잡아내기 위해 기본적인 검사를 할 수 있다.

Content-MD5 헤더는 서버가 엔티티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다.

메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

## 15.4 미디어 타입과 차셋
Content-Type 헤더 필드는 엔티티 본문의 MIME 타입을 기술한다.
MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.

Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME이다.
MIME 타입은 주 미디어 타입으로 시작해서 뒤이어 빗금(/), 그리고 미디어 타입을 더 구체적으로 서술하는 부 타입으로 구성된다.
  |명칭|엔터티 본문|
  |---|---|
  |text/html| HTML 문서|
  |text/plain| 플레인 텍스트 문서|
  |mage/gif| GIF 이미지|
  |mage/jpeg| JPEG 이미지|
  |audio/x-wav| WAV 음향데이터|
  |model/vrml| 삼차원 VRML 모델|
  |application/vnd.ms-powerpoint| MS 파워포인트 프레젠테이션|
  |multipart/byteranges| 전체 문서의 특정 범위(Byte 단위) 담은 여러 부분으로 나뉨 |
  |message/http| 완전한 HTTP 메세지 (6장의 TRACE 메소드 참고)|
  
### 15.4.1 텍스트 매체를 위한 문자 인코딩
Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
엔티티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 그 대표적인 예이다.

### 15.4.2 멀티파트 미디어 타입
MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며 하나의 복합 메시지로 보내진다. 각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함하며, 여러 구성요소들이 이어져 있고 문자열 하나로 서로의 경계가 식별된다.

### 15.4.3 멀티파트 폼 제출
HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다. 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.

### 15.4.4 멀티파트 범위 응답
범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다.
그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

## 15.5 콘텐츠 인코딩
HTTP 애플리케이션은 암호화 혹은 전송시간을 줄이기 위해 콘텐츠를 보내기 전에 인코딩을 하려고 한다.
이러한 종류의 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다.

### 15.5.1 콘텐츠 인코딩 과정
콘텐츠 인코딩 과정은 다음과 같다.
1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩 할 수 있도록 한다.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형
HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다. 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.
  |명칭|무손실 압축|상세|
    |---|---|---|
    |gzip|o| GNU zip 인코딩 적용됨 <br> (효율적이고 널리 사용되는 압축 알고리즘)|
    |compress|o|compress가 실행됨 <br> (유닉스의 파일압축 프로그램)|
    |deflate|o|zlib 포맷으로 압축됨|
    |identity|x|- 어떤 인코딩도 적용 안 됨 <br> - Content-Encoding 없는 경우 이 값으로 간주|
gzip,compress,deflate 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.

### 15.5.3 Accept-Encoding 헤더
우리는 클라이언트가 해독할 수 없는 방법으로 서버가 콘텐츠를 인코딩하는 것을 원하지 않는다.
이를 방지하기 위해 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.

클라이언트는 각 인코딩에 Q값을 매개변수로 더해 선호도를 나타낼 수 있다.(0.0-1.0)
